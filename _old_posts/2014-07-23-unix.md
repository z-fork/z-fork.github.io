---
title: unix
layout: post
tags:
  - c
  - unix

---

第3章 文件

  3.1 引言

    unbuffered I/O: open, read, write, lseek, close.
    这些不带缓存的I/O函数不是ANSI C 的组成部分,但是是 POSIX.1和XPG3的组成部分

    多个进程间共享资源, 原子操作的概念就变成非常重要.我们将通过文件 I/O
    和传送给open函数的参数来讨论此概念.并进一步讨论在多个进程间如何共享文件,并涉及内
    核的有关数据结构.在讨论了这些特征后,将说明 dup、fcntl和ioctl函数

  3.2 文件描述符

    UNIX shell使文件描述符:
        0与进程的标准输入相结合,
        1与标准输出相结合,
        2与标准出错输出相结合

    在POSIX.1应用程序中,幻数 0、1、2应被代换成符号常数 STDIN_FILENO、STDOUT_    FILENO和STDERR_FILENO.
    这些常数都定义在头文件<unistd.h>中

    文件描述符的范围是 0 ~ O P E N _ M A X (见表2 - 7 ).早期的 U N I X版本采用的上限值是 1 9 (允许
    每个进程打开20个文件),现在很多系统则将其增加至 63

  3.3 open函数

    open函数可以打开或创建一个文件

    int open(const char *pathname, int oflag, . . . /*, mode_t mode */);
    
    返回:若成功为文件描述符,若出错为 -1

    仅当创建新文件时才使用第三个参数.

    三个常数中应当只指定一个

    • O_RDONLY 只读打开.
    • O_WRONLY 只写打开.
    • O_RDWR 读、写打开.

    下列常数则是可选择

    • O_APPEND 每次写时都加到文件的尾端. 3.11节详细说明.

    • O_CREAT 若此文件不存在则创建它. 使用此选择项时,需同时说明第三个参数 mode,
    用其说明该新文件的存取许可权位. ( 4.5节将说明文件的许可权位,那时就能了解如何说明
    mode,以及如何用进程的umask值修改它. )

    • O_EXCL 如果同时指定了O_CREAT,而文件已经存在,则出错.这可测试一个文件是
    否存在,如果不存在则创建此文件成为一个原子操作. 3.11节将较详细地说明原子操作.

    • O_TRUNC 如果此文件存在,而且为只读或只写成功打开,则将其长度截短为 0.

    • O_NOCTTY 如果pathname指的是终端设备,则不将此设备分配作为此进程的控制终端.
    9.6节将说明控制终端.

    • O_NONBLOCK 如果pathname指的是一个FIFO、一个块特殊文件或一个字符特殊文件,
    则此选择项为此文件的本次打开操作和后续的 I / O操作设置非阻塞方式. 1 2 . 2节将说明此工作
    方式.

    • O_SYNC 使每次write都等到物理I/O操作完成.3.13节将使用此选择项.

    open返回的文件描述符一定是最小的未用描述符数字.这一点被很多应用程序用来在标
    准输入、标准输出或标准出错输出上打开一个新的文件.例如,一个应用程序可以先关闭标准
    输出(通常是文件描述符 1 ),然后打开另一个文件,事先就能了解到该文件一定会在文件描述
    符1上打开.在 3.12节说明 dup2函数时,可以了解到有更好的方法来保证在一个给定的描述符
    上打开一个文件

  3.4 creat函数

    int creat(const char *pathname, mode_t mode);

    返回:若成功为只写打开的文件描述符,若出错为- 1

    此函数等效于

    open(pathname, O_WRONLY|O_CREAT|O_TRUNC, mode);

    早期的 UNIX版本中, open的第二个参数只能是 0、1或2.没有办法打开一
    个尚未存在的文件,因此需要另一个系统调用 creat以创建新文件.现在, open函
    数提供了选择项O_CREAT和O_TRUNC,于是也就不再需要creat函数了

    creat的一个不足之处是它以只写方式打开所创建的文件.在提供 open的新版本之前,如果
    要创建一个临时文件,并要先写该文件,然后又读该文件,则必须先调用 creat,close,然后再
    调用open.现在则可用下列方式调用 open:
    
    open(pathname, O_RDWR|O_CREAT|O_TRUNC, mode);

  3.5 close函数

    int close (int filedes);

    返回:若成功为 0,若出错为- 1

    关闭一个文件时也释放该进程加在该文件上的所有记录锁. 12.3节将讨论这一点.
    
    当一个进程终止时,它所有的打开文件都由内核自动关闭.很多程序都使用这一功能而不
    显式地用close关闭打开的文件

  3.6 lseek函数

    每个打开文件都有一个与其相关联的“当前文件位移量”.它是一个非负整数,用以度量
    从文件开始处计算的字节数. (本节稍后将对“非负”这一修饰词的某些例外进行说明. )通常,
    读、写操作都从当前文件位移量处开始,并使位移量增加所读或写的字节数.按系统默认,当
    打开一个文件时,除非指定 O_APPEND选择项,否则该位移量被设置为 0

    调用lseek显式地定位一个打开文件

    off_t lseek(int filedes, off_t offset, int whence);

    返回:若成功为新的文件位移,若出错为 -1

    • 若whence是SEEK_SET,则将该文件的位移量设置为距文件开始处 offset 个字节.
    • 若whence是SEEK_CUR,则将该文件的位移量设置为其当前值加offset, offset可为正或负.
    • 若whence是SEEK_END,则将该文件的位移量设置为文件长度加offset, offset可为正或负.

  3.7 read函数

    ssize_t read(int filedes, void *buff, size_t nbytes);

    返回:读到的字节数,若已到文件尾为 0,若出错为 -1

  3.8 write函数

    ssize_t write(int filedes, const void *buff, size_t nbytes);

    返回:若成功为已写的字节数,若出错为 -1

    write出错的一个常见原因是:磁盘已写满,或者超过了对一个给定进程的文件长度限制 (见7.11节及习题10.11)

    只使用read和write函数来复制一个文件

    #define BUFFSIZE 8192

    int
    main(void)
    {
      int n;
      char buf[BUFFSIZE];

      while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
        if (write(STDOUT_FILENO, buf, n) != n)
          err_sys("write error");
      
      if (n < 0)
        err_sys("read error");

      exit(0);
    }

  3.10 文件共享

    UNIX支持在不同进程间共享打开文件.在介绍 dup函数之间,需要先说明这种共享.为此
    先说明内核用于所有I/O的数据结构.
    内核使用了三种数据结构,它们之间的关系决定了在文件共享方面一个进程对另一个进程
    可能产生的影响.
    (1) 每个进程在进程表中都有一个记录项,每个记录项中有一张打开文件描述符表,可将
    其视为一个矢量,每个描述符占用一项.与每个文件描述符相关联的是:
        (a) 文件描述符标志.
        (b) 指向一个文件表项的指针.
    (2) 内核为所有打开文件维持一张文件表.每个文件表项包含:
        (a) 文件状态标志(读、写、增写、同步、非阻塞等 ).
        (b) 当前文件位移量.
        (c) 指向该文件v节点表项的指针

    (3) 每个打开文件(或设备)都有一个 v节点结构. v节点包含了文件类型和对此文件进
    行各种操作的函数的指针信息.对于大多数文件, v节点还包含了该文件的 i节点(索引节
    点) .这些信息是在打开文件时从盘上读入内存的,所以所有关于文件的信息都是快速可供
    使用的.例如, i节点包含了文件的所有者、文件长度、文件所在的设备、指向文件在盘上
    所使用的实际数据块的指针等等( 4 . 1 4节较详细地说明了 U N I X文件系统,将更多地介绍 i节点.)

    进程的三张表之间的关系. 进程表项 - 文件表 - v节点表

    • 在完成每个 write后,在文件表项中的当前文件位移量即增加所写的字节数.如果这使当
    前文件位移量超过了当前文件长度,则在 i节点表项中的当前文件长度被设置为当前文件位移
    量(也就是该文件加长了)
    .
    • 如果用O_APPEND标志打开了一个文件,则相应标志也被设置到文件表项的文件状态标
    志中.每次对这种具有添写标志的文件执行写操作时,在文件表项中的当前文件位移量首先被
    设置为i节点表项中的文件长度.这就使得每次写的数据都添加到文件的当前尾端处.
    • lseek函数只修改文件表项中的当前文件位移量,没有进行任何 I/O操作.
    • 若一个文件用lseek被定位到文件当前的尾端,则文件表项中的当前文件位移量被设置为 i
    节点表项中的当前文件长度.
    
    可能有多个文件描述符项指向同一文件表项.在 3 . 1 2节中讨论 d u p函数时,我们就能看到
    这一点.在fork后也发生同样的情况,此时父、子进程对于每一个打开的文件描述符共享同一
    个文件表项.

    文件描述符标志和文件状态标志在作用范围方面的区别,前者只用于一个进程的一
    个描述符,而后者则适用于指向该给定文件表项的任何进程中的所有描述符.在 3 . 1 3节说明
    fcntl函数时,我们将会了解如何存取和修改文件描述符标志和文件状态标志.

  3.11 原子操作

    3.11.1 添加至一个文件

    多个进程同时执行,各自将消息添加到一个日记文件中,就会产生这种情况

    这里的问题出在逻辑操作“定位档到文件尾端处,然后写”使用了两个分开的函数调用.
    解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作.任何一个要求多于 1个
    函数调用的操作都不能成为原子操作,因为在两个函数调用之间,内核有可能会临时挂起该进
    程(正如我们前面所假定的)

    Q: 函数为单位切换? 还是已什么为单位? 不是时间片?

    UNIX 提供了一种方法使这种操作成为原子操作,其方法就是在打开文件时设置
    O_APPEND标志.正如前一节中所述,这就使内核每次对这种文件进行写之前,都将进程的
    当前位移量设置到该文件的尾端处,于是在每次写之前就不再需要调用 lseek

    3.11.2 创建一个文件

    o p e n函数的 O _ C R E AT和O _ E X C L选择项进行说明时,我们已见到了另一个有关原子
    操作的例子.当同时指定这两个选择项,而该文件又已经存在时, open将失败

    我们曾提及检查该文件是否存在以及创建该文件这两个操作是作为一个原子操作执行的.如果没有这样一个
    原子操作

    在 4.15节论述link函数以及在12.3节中述及记录锁时,还将讨论原子操作

  3.12 dup和dup2函数

    两个函数都可用来复制一个现存的文件描述符

  3.13 fcntl函数

    fcntl函数有五种功能:

    • 复制一个现存的描述符(cmd=F_DUPFD)
    
    • 获得/设置文件描述符标记(cmd=F_GETFD或F_SETFD)
    
    • 获得/设置文件状态标志(cmd=F_GETFL或F_SETFL)
    
    • 获得/设置异步I/O有权(cmd=F_GETOWN或F_SETOWN)
    
    • 获得/设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW)

    我们先说明这十种命令值中的前七种 ( 1 2 . 3节说明后三种,它们都与记录锁有关 )我们将涉
    及与进程表项中各文件描述符相关联的文件描述符标志,
    以及每个文件表项中的文件状态标志,
    见图3-1.
    • F_DUPFD 复制文件描述符filedes,新文件描述符作为函数值返回.它是尚未打开的各
    描述符中大于或等于第三个参数值(取为整型值)中各值的最小值.新描述符与 filedes 共享同
    一文件表项(见图 3 - 3)
    .但是,新描述符有它自己的一套文件描述符标志,其 F D _ C L O E X E C
    文件描述符标志则被清除(这表示该描述符在 exec 时仍保持开放,我们将在第 8章对此进行
    讨论)
    
    • F_GETFD 对应于filedes 的文件描述符标志作为函数值返回.当前只定义了一个文件描
    述符标志FD_CLOEXEC.
    • F_SETFD 对于filedes 设置文件描述符标志.新标志值按第三个参数 (取为整型值)设置.
    应当了解很多现存的涉及文件描述符标志的程序并不使用常数 F D _ C L O E X E C,而是将此
    标志设置为0(系统默认,在exec时不关闭)或1(在exec时关闭).
    • F_GETFL 对应于filedes 的文件状态标志作为函数值返回.在说明 open函数时,已说明
    了文件状态标志.它们列于表 3-2中.
    表3-2 对于fcntl的文件状态标志
    文件状态标志
    说
    明
    O_RDONLY 只读打开
    O_WRONLY 只写打开
    O_RDWR 读/写打开
    O_APPEND 写时都添加至文件尾
    O_NONBLOCK 非阻塞方式
    O_SYNC 等待写完成
    O_ASYNC 异步I/O(仅4.3+BSD)

    不幸的是,三个存取方式标志 (O_RDONLY,O_WRONLY,以及O_RDWR)并不各占1位.(正
    如前述,这三种标志的值各是 0、1和2,由于历史原因.这三种值互斥 — 一个文件只能有这
    三种值之一. )因此首先必须用屏蔽字 O_ACCMODE取得存取方式位,然后将结果与这三种值
    相比较.

    • F_SETFL 将文件状态标志设置为第三个参数的值 (取为整型值).
    可以更改的几个标志是:
    O_APPEND,O_NONBLOCK,O_SYNC和O_ASYNC.
    • F_GETOWN 取当前接收SIGIO和SIGURG信号的进程ID或进程组ID.12.6.2节将论述这
    两种4.3+BSD异步I/O信号.
    • F_SETOWN 设置接收SIGIO和SIGURG信号的进程ID或进程组ID.正的arg指定一个进
    程ID,负的arg表示等于arg绝对值的一个进程组ID.
    fcntl的返回值与命令有关.如果出错,所有命令都返回- 1,如果成功则返回某个其他值.
    下列三个命令有特定返回值: F_DUPFD,F_GETFD, F_GETFL以及F_GETOWN.第一个返回新
    的文件描述符,第二个返回相应标志,最后一个返回一个正的进程 ID或负的进程组ID.


第4章 文件和目录

  4.1 引言

  4.2 stat、fstat 和lstat 函数

    使用stat函数最多的可能是 ls -l命令,用其可以获得有关一个文件的所有信息

  4.3 文件类型

    (1) 普通文件(regular file).这是最常见的文件类型,这种文件包含了某种形式的数据.至
    于这种数据是文本还是二进制数据对于内核而言并无区别.对普通文件内容的解释由处理该文
    件的应用程序进行.
    (2) 目录文件(directory file).这种文件包含了其他文件的名字以及指向与这些文件有关信
    息的指针.对一个目录文件具有读许可权的任一进程都可以读该目录的内容,但只有内核可以
    写目录文件.
    (3) 字符特殊文件(character special file).这种文件用于系统中某些类型的设备.
    (4) 块特殊文件(block special file).这种文件典型地用于磁盘设备.系统中的所有设备或者
    是字符特殊文件,或者是块特殊文件.
    (5) FIFO.这种文件用于进程间的通信,有时也将其称为命名管道.14.5节将对其进行说明.
    (6) 套接口(socket).这种文件用于进程间的网络通信.套接口也可用于在一台宿主机上的
    进程之间的非网络通信.第15章将用套接口进行进程间的通信.
    (7) 符号连接(symbolic link).这种文件指向另一个文件.4.16节将更多地述及符号连接.
    文件类型信息包含在 s t a t结构的 s t _ m o d e成员中.可以用表 4 - 1中的宏确定文件类型.这些
    宏的参数都是stat结构中的st_mode成员




第5章 标 准 I/O 库

  5.1 引言

  5.2 流和FILE对象

    unbuffered I/O函数都是针对文件描述符的.当打开一个文件时,即返回一个文件描
    述符,然后该文件描述符就用于后读的 I / O操作.

    标准 I / O库,它们的操作则是围绕流
    (stream)进行的(请勿将标准 I/O术语流与系统V的STREAMS I/O系统相混淆)
    .当用标准 I/O库打开或创建一个文件时,我们已使一个流与一个文件相结合

    当打开一个流时,标准 I/O函数fopen返回一个指向FILE对象的指针.该对象通常是一个结
    构,它包含了I/O库为管理该流所需要的所有信息:用于实际 I/O的文件描述符,指向流缓存的
    指针,缓存的长度,当前在缓存中的字符数,出错标志等等.

  5.3 标准输入、标准输出和标准出错

    标准I / O流通过预定义文件指针 s t d i n , s t d o u t和s t d e r r加以引用

  5.4 缓存

    标准I/O提供了三种类型的缓存:

    (1) 全缓存.在这种情况下,当填满标准 I/O缓存后才进行实际I/O操作
    (2) 行缓存.在这种情况下,当在输入和输出中遇到新行符时,标准 I/O库执行I/O操作
    (3) 不带缓存.标准 I / O库不对字符进行缓存

    ANSI C要求下列缓存特征:

    (1) 当且仅当标准输入和标准输出并不涉及交互作用设备时,它们才是全缓存的.
    (2) 标准出错决不会是全缓存的

    对任何一个给定的流,如果我们并不喜欢这些系统默认,则可调用下列两个函数中的一个
    更改缓存类型:

    void setbuf(FILE* fp, char buf);
    int setvbuf(FILE* fp, char buf, int mode, size_t size);

    返回:若成功则为 0,若出错则为非 0

    这些函数一定要在流已被打开后调用, 而且也应在对该流执行任何一个其他操作之前调用

    可以使用s e t b u f函数打开或关闭缓存机制.为了带缓存进行 I / O,参数buf 必须指向一个长
    度为BUFSIZ的缓存(该常数定义在 <stdio.h>中)
    .通常在此之后该流就是全缓存的,但是如果
    该流与一个终端设备相关,那么某些系统也可将其设置为行缓存的.为了关闭缓存,将 b u f设
    置为NULL.
    使用setvbuf,我们可以精确地说明所需的缓存类型.这是依靠 mode参数实现的:
    _IOFBF 全缓存
    _IOLBF 行缓存
    _ I O N B F 不带缓存
    如果指定一个不带缓存的流,则忽略 buf 和size 参数.如果指定全缓存或行缓存,则 buf 和size
    可以可选择地指定一个缓存及其长度.如果该流是带缓存的,而 buf 是NULL,则标准I/O库将
    自动地为该流分配适当长度的缓存.适当长度指的是由 s t r u c t结构中的成员 s t _ b l k s i z e所指定的
    值(见 4 . 2节)
    .如果系统不能为该流决定此值(例如若此流涉及一个设备或一个管道)
    ,则分
    配长度为BUFSIZ的缓存

    如果在一个函数中分配一个自动变量类的标准 I / O缓存,则从该函数返回之前,必须关闭该流.(7.8节将对此作更多讨论.)

    一般而言,应由系统选择缓存的长度,并自动分配缓存.在这样处理时,标准 I/O库在关闭此流时将自动释放此缓存

    任何时候,我们都可强制刷新一个流

    int fflush(FILE* fp);

    返回:若成功则为 0,若出错则为 E O F

    此函数使该流所有未写的数据都被传递至内核.作为一种特殊情形,如若 fp是NULL,则此函数刷新所有输出流

  5.5 打开流


    当以读和写类型打开一文件时( type中+号),具有下列限制:
    • 如果中间没有fflush、fseek、fsetpos或rewind,则在输出的后面不能直接跟随输入.
    • 如果中间没有 fseek、fsetpos或rewind,或者一个输出操作没有到达文件尾端,则在输入操
    作之后不能直接跟随输出.























FIFO有时被称为命名管道.管道只能由相关进程使用,它们共同的祖先进程创建了管道.
但是,通过FIFO,不相关的进程也能交换数据

























    write (APUE 275 12. I/O)



    #include <sys/types.h>
    #include <errno.h>
    #include <unistd.h>
    #include <stdio.h>
    #include <fcntl.h>

    void
    set_fl(int fd, int flags) /* flags are file status flags to turn on */
    {
      int val;
      if ((val = fcntl(fd, F_GETFL, 0)) < 0)
      {
        printf("fcntl F_GETFL error");
        exit(1);
      }

      val |= flags;        /* turn on flags */
     
      if (fcntl(fd, F_SETFL, val) < 0)
      {
        printf("fcntl F_SETFL error");
        exit(1);
      }
    }

    void
    clr_fl(int fd, int flags)
    {
      int val;

      if ((val = fcntl(fd, F_GETFL, 0)) == -1)
      {
        //syslog(LOG_ERR, __FILE__, __LINE__,"fcntl() error : %s", strerror(errno));
        exit(1);
      }
      val &= ~flags; /* turn flags off */

      if (fcntl(fd, F_SETFL, val) == -1)
      {
        //syslog(LOG_ERR, __FILE__, __LINE__,"fcntl() error : %s", strerror(errno));
        exit(1);
      }
      return;
    }

    char buf[100000];

    int
    main(void)
    {
      int ntowrite, nwrite;
      char* ptr;

      ntowrite = read(STDIN_FILENO, buf, sizeof(buf));
      fprintf(stderr, "read %d bytes\n", ntowrite);

      set_fl(STDOUT_FILENO, O_NONBLOCK);

      for (ptr = buf; ntowrite > 0;)
      {
        errno = 0;
        nwrite = write(STDOUT_FILENO, ptr, ntowrite);
        fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno);
        if (nwrite > 0)
        {
            ptr += nwrite;
            ntowrite -= nwrite;
        }
      }

      clr_fl(STDOUT_FILENO, O_NONBLOCK);
      exit(0);
    }








第7章 UNIX进程的环境

  7.1 引言
    
    下一章将介绍进程控制原语,在此之前需先了解进程的环境.

    当执行程序时,其main函数是如何被调用的,命令行参数是如何传送给执行程序的;
    典型的存储器布局是什么样式;
    如何分配另外的存储空间;
    进程如何使用环境变量;
    进程终止的不同方式等.

    还将说明longjmp和setjmp函数以及它们与栈的交互作用,
    还将查看进程的资源限制

  7.2 main函数

    当内核起动C程序时(使用一个 e x e c函数,8 . 9节将说明 e x e c函数),在调用 m a i n前先调用一
    个特殊的起动例程.可执行程序文件将此起动例程指定为程序的起始地址——这是由连接编辑
    程序设置的,而连接编辑程序则由 C编译程序 (通常是c c )调用.起动例程从内核取得命令行参
    数和环境变量值,然后为调用 main函数作好安排.

  7.3 进程终止

    有五种方式使进程终止:
    (1) 正常终止:
        (a) 从main返回.
        (b) 调用exit.
        (c) 调用_exit.
    (2) 异常终止:
        (a) 调用abort(见第10章).
        (b) 由一个信号终止 (见第10章).

  7.3.1 exit和_exit函数

    用于正常终止一个程序: 
        _ e x i t立即进入内核, 
        e x i t则先执行一些清除处理(包括调用执行各终止处理程序,关闭所有标准 I/O流等),然后进入内核.

    将在8.5节中讨论这两个函数对其他进程,例如终止进程的父、子进程的影响.

    exit函数总是执行一个标准 I/O库的清除关闭操作:对于所有打开流调用fclose函数。
    回忆5.5节,这造成缓存中的所有数据都被刷新 (写到文件上)。

    下一章将了解进程如何使程序执行,如何等待执行该程序的进程完成,然后取得其终止状态.

  7.3.2 atexit函数

    按照ANSI C的规定,一个进程可以登记多至 32个函数,这些函数将由 exit自动调用。
    我们称这些函数为终止处理程序( exit handler),并用atexit函数来登记这些函数。

    #include "ourhdr.h"

    static void my_exit1(void), my_exit2(void);

    int
    main(void)
    {
      if (atexit(my_exit2) != 0)
        err_sys("can't register my_exit2");

      if (atexit(my_exit1) != 0)
        err_sys("can't register my_exit1");
      if (atexit(my_exit1) != 0)
        err_sys("can't register my_exit1");

      printf("main is done\n");
      return(0);
    }

  7.4 命令行参数

    for (i = 0; i < argc; i++) /* echo all command-line args */
      printf("argv[%d]: %s\n", i, argv[i]);

  7.5 环境表

    每个程序都接收到一张环境表。与参数表一样,环境表也是一个字符指针数组,其中每个
    指针包含一个以 null结束的字符串的地址。全局变量 environ则包含了该指针数组的地址。

    extern char **environ;

    通常用 g e t e n v和p u t e n v函
    数(7.9节将说明 )来存取特定的环境变量,而不是用 environ变量。但是,如果要查看整个环境,
    则必须使用environ指针。

  7.6 C程序的存储空间布局

    • 正文段。
    这是由 CPU执行的机器指令部分。通常,正文段是可共享的,所以即使是经常
    执行的程序 (如文本编辑程序、 C编译程序、 s h e l l等)在存储器中也只需有一个副本,另外,正
    文段常常是只读的,以防止程序由于意外事故而修改其自身的指令。
    • 初始化数据段。
    通常将此段称为数据段,它包含了程序中需赋初值的变量。例如, C程
    序中任何函数之外的说明:
    int maxcount = 99;
    使此变量以初值存放在初始化数据段中。
    • 非初始化数据段。
    通常将此段称为 b s s段,这一名称来源于早期汇编程序的一个操作符,
    意思是“block started by symbol(由符号开始的块)”,在程序开始执行之前,内核将此段初始化为0。
    函数外的说明:
    long sum[1000] ;
    使此变量存放在非初始化数据段中。
    • 栈。
    自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时,
    其返回地址、以及调用者的环境信息(例如某些机器寄存器)都存放在栈中。然后,新被调
    用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈, C函数可以递归
    调用。
    • 堆。
    通常在堆中进行动态存储分配。由于历史上形成的惯例,堆位于非初始化数据段顶
    和栈底之间。

    size(1)命令报告正文段、数据段和 bss段的长度(单位:字节)。例如:

    $ size /bin/cc /bin/sh
    text    data    bss    dec    hex
    81920   16384   664    98968  18298    /bin/cc
    90112   16384   0      106496 1a000    /bin/sh

    第4和第5列是分别以十进制和十六进制表示的总长度。

  7.7 共享库

    用动态连接方法将程序与共享库函数相连接。这减少了每个可执行
    文件的长度,但增加了一些运行时间开销。共享库的另一个优点是可以用库函数的新版本代替老
    版本而无需对使用该库的程序重新连接编辑。(假定参数的数目和类型都没有发生改变。)
    不同的系统使用不同的方法使说明程序是否要使用共享库。比较典型的有 cc(1)和ld(1)命令
    的可选项。

  7.8 存储器分配

    ANSI C说明了三个用于存储空间动态分配的函数。
    (1) malloc。分配指定字节数的存储区。此存储区中的初始值不确定。
    (2) calloc。为指定长度的对象,分配能容纳其指定个数的存储空间。该空间中的每一位
    (bit)都初始化为0。
    (3) realloc。更改以前分配区的长度 (增加或减少)。当增加长度时,可能需将以前分配区的
    内容移到另一个足够大的区域,而新增区域内的初始值则不确定。

    这三个分配函数所返回的指针一定是适当对齐的,使其可用于任何数据对象。

    函数free释放ptr指向的存储空间。被释放的空间通常被送入可用存储区池,以后可在调用分配函数时再分配。

    r e a l l o c使我们可以增、减以前分配区的长度 (最常见的用法是增加该区 )。例如,如果先分
    配一个可容纳长度为 5 1 2的数组的空间,并在运行时填充它,但又发现空间不够,则可调用
    realloc扩充该存储空间。如果在该存储区后有足够的空间可供扩充,则可在原存储区位置上向
    高地址方向扩充,并返回传送给它的同样的指针值。如果在原存储区后没有足够的空间,则
    r e a l l o c分配另一个足够大的存储区,将现存的 5 1 2个元素数组的内容复制到新分配的存储区。
    因为这种存储区可能会移动位置,所以不应当使用任何指针指在该区中。

    这些分配例程通常通过sbrk(2)系统调用实现。

    虽然sbrk可以扩充或缩小一个进程的存储空间,但是大多数 malloc和free的实现都不减小进
    程的存储空间。释放的空间可供以后再分配,但将它们保持在 malloc池中而不返回给内核。

    alloca函数

    其调用序列与 m a l l o c相同,但是它是在当前函数的栈帧上分配存储空间,而不是在堆中。
    其优点是:当函数返回时,自动释放它所使用的栈帧,所以不必再为释放空间而费心。
    其缺点是:某些系统在函数已被调用后不能增加栈帧
    长度,于是也就不能支持 alloca函数。

  7.9 环境变量

    ANSI C定义了一个函数getenv,可以用其取环境变量值,但是该标准又称环境的内容是由
    实现定义的。

    • putenv取形式为name=value的字符串,将其放到环境表中。如果 name已经存在,则先删
    除其原来的定义。
    • setenv将name设置为value。如果在环境中 name已经存在,那么 (a)若rewrite非0,则首先
    删除其现存的定义; (b)若rewrite为0,则不删除其现存定义(name不设置为新的value,而且也
    不出错)
    。
    • unsetenv删除name的定义。即使不存在这种定义也不算出错。

    这些函数在修改环境表时是如何进行操作的呢?回忆一下图 7 - 3,其中,环境表(指向实
    际name=value字符串的指针数组)和环境字符串典型地存放在进程存储空间的顶部(栈之上)。
    删除一个字符串很简单——只要先找到该指针,然后将所有后续指针都向下移一个位置。但是
    增加一个字符串或修改一个现存的字符串就比较困难。栈以上的空间因为已处于进程存储空间
    的顶部,所以无法扩充,即无法向上扩充,也无法向下扩充。

    (1) 如果修改一个现存的 name:
    (a) 如果新 v a l u e的长度少于或等于现存 v a l u e的长度,则只要在原字符串所用空间中写
    入新字符串。
    (b) 如果新value的长度大于原长度,则必须调用 malloc为新字符串分配空间,然后将新
    字符写入该空间中,然后使环境表中针对 name的指针指向新分配区。
    (2) 如果要增加一个新的 name,则操作就更加复杂。首先,调用 malloc为name=value分配
    空间,然后将该字符串写入此空间中。
    (a) 然后,如果这是第一次增加一个新 name,则必须调用malloc为新的指针表分配空间。
    将原来的环境表复制到新分配区,并将指向新 name=value的指针存在该指针表的表
    尾,然后又将一个空指针存在其后。最后使 environ指向新指针表。再看一下图 7-3,
    如果原来的环境表位于栈顶之上 (这是一种常见情况 ),那么必须将此表移至堆中。
    但是,此表中的大多数指针仍指向栈顶之上的各 name=value字符串。
    (b) 如果这不是第一次增加一个新 name,则可知以前已调用 malloc在堆中为环境表分配
    了空间,所以只要调用 realloc,以分配比原空间多存放一个指针的空间。然后将该
    指向新name=value字符串的指针存放在该表表尾,后面跟着一个空指针。

  7.10 setjmp和longjmp函数

    在C中,不允许使用跳越函数的 goto语句。而执行这种跳转功能的是函数 setjmp和longjmp。
    这两个函数对于处理发生在很深的嵌套函数调用中的出错情况非常有用。

第8章 进 程 控 制

  8.1 引言

    本章介绍 U N I X的进程控制,包括创建新进程、执行程序和进程终止。
    还将说明进程的各种ID—实际、有效和保存的用户和组ID,以及它们如何受到进程控制原语的影响。本章也包
    括了解释器文件和 s y s t e m函数。本章以大多数 U N I X系统所提供的进程会计机制结束。这使我
    们从一个不同角度了解进程控制功能。

  8.2 进程标识

    每个进程都有一个非负整型的唯一进程 ID。

    有某些专用的进程:进程 ID 0是调度进程,常常被称为交换进程 (swapper)。该进程并不执
    行任何磁盘上的程序—它是内核的一部分,因此也被称为系统进程。进程 ID 1通常是 i n i t进
    程,在自举过程结束时由内核调用。

    init通常读与系统有关的初始化文件(/etc/rc*文件),并将系统引导到一个状态 (例如多用户)。
    init进程决不会终止。它是一个普通的用户进程 (与交换进程不同,它不是内核中的系统进程 ),
    但是它以超级用户特权运行。本章稍后部分会说明 init如何成为所有孤儿进程的父进程。

    在某些UNIX的虚存实现中,进程ID 2 是页精灵进程(pagedaemon)。此进程负责支持虚存系
    统的请页操作。与交换进程一样,页精灵进程也是内核进程。

  8.3 fork函数

    一个现存进程调用 f o r k函数是U N I X内核创建一个新进程的唯一方法 (这并不适用于前节提
    及的交换进程、 i n i t进程和页精灵进程。这些进程是由内核作为自举过程的一部分以特殊方式
    创建的)。

    该函数被调用一次,但返回两次。两次返回的区别是子进程的返回值是 0,而父进程的返回值则是新子进程的进程 ID。

    子进程和父进程继续执行 fork之后的指令。

    子进程是父进程的复制品。例如,子进程获得父进程数据空间、堆和栈的复制品。这是子进程所拥有的拷贝。

    父、子进程并不共享这些存储空间部分。如果正文段是只读的,则父、子进程共享正文段

    现在很多的实现并不做一个父进程数据段和堆的完全拷贝,因为在 f o r k之后经常跟随着
    exec。作为替代,使用了在写时复制 (Copy-On-Write, COW)的技术。这些区域由父、子进程共
    享,而且内核将它们的存取许可权改变为只读的。如果有进程试图修改这些区域,则内核为有
    关部分,典型的是虚存系统中的“页”
    ,做一个拷贝。

    fork 函数实例

    #include <sys/types.h>
    #include "ourhdr.h"

    int glob = 6;
    char buf[] = "a write to stdout\n";

    int
    main(void)
    {
      int var;
      pid_t pid;

      var = 88;
      if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)
        err_sys("write error");
      printf("before fork\n");
      if ((pid = fork()) < 0)
        err_sys("fork error");
      else if (pid == 0){
        glob++;
        var++;
      } else
        sleep(2);
      printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
      exit(0);
    }

    $ a.out
    a write to stdout
    before fork
    pid = 430, glob = 7, v a r = 8 9 子进程的变量值改变了
    pid = 429, glob = 6, v a r = 8 8 父进程的变量值没有改变

    $ a.out > temp.out
    $ cat temp.out
    a write to stdout
    before fork
    pid = 432, glob = 7, var = 89
    before fork
    pid = 431, glob = 6, var = 88

    write函数是不带缓存的。
    因为在 f o r k之前调用 w r i t e,所以其数据写到标准输出一次。但是,标准 I / O库是带缓存的。回
    忆一下5.12节,如果标准输出连到终端设备,则它是行缓存的,否则它是全缓存的。当以交互
    方式运行该程序时,只得到 p r i n t f输出的行一次,其原因是标准输出缓存由新行符刷新。但是
    当将标准输出重新定向到一个文件时,却得到 printf输出行两次。其原因是,在 fork之前调用了
    printf一次,但当调用fork时,该行数据仍在缓存中,然后在父进程数据空间复制到子进程中时,
    该缓存数据也被复制到子进程中。于是那时父、子进程各自有了带该行内容的缓存。在 exit之
    前的第二个 p r i n t f将其数据添加到现存的缓存中。当每个进程终止时,其缓存中的内容被写到
    相应文件中。

    需注意的另一点是:在重新定向父进程的标准输出时,子进程的标准输出也被
    重新定向。实际上, f o r k的一个特性是所有由父进程打开的描述符都被复制到子进程中。父、
    子进程每个相同的打开描述符共享一个文件表项 (见图3-3)。

    如果父、子进程写到同一描述符文件,但又没有任何形式的同步(例如使父进程等待子进程)
    ,那么它们的输出就会相互混合(假定所用的描述符是在 fork之前打开的)

    在fork之后处理文件描述符有两种常见的情况:
    (1) 父进程等待子进程完成。在这种情况下,父进程无需对其描述符做任何处理。当子进
    程终止后,它曾进行过读、写操作的任一共享描述符的文件位移量已做了相应更新。
    (2) 父、子进程各自执行不同的程序段。在这种情况下,在 fork之后,父、子进程各自关闭
    它们不需使用的文件描述符,并且不干扰对方使用的文件描述符。这种方法是网络服务进程中
    经常使用的。

    使fork失败的两个主要原因是: (a)系统中已经有了太多的进程 (通常意味着某个方面出了问
    题),或者(b)该实际用户ID的进程总数超过了系统限制。回忆表 2-7,其中CHILD_MAX规定了
    每个实际用户ID在任一时刻可具有的最大进程数。

    fork有两种用法:
    (1) 一个父进程希望复制自己,使父、子进程同时执行不同的代码段。这在网络服务进程
    中是常见的——父进程等待委托者的服务请求。当这种请求到达时,父进程调用 fork,使子进
    程处理此请求。父进程则继续等待下一个服务请求。
    (2) 一个进程要执行一个不同的程序。这对 s h e l l是常见的情况。在这种情况下,子进程在
    从fork返回后立即调用exec(我们将在8.9节说明exec)。

    某些操作系统将 (2)中的两个操作(fork之后执行 exec)组合成一个,并称其为 spawn。

    将这两个操作分开,使得子进程在 fork和exec之间可以更改自己的属性。例如 I/O重新定向、用户 ID、信
    号排列等。在第14章中有很多这方面的例子。

  8.4 vfork函数

    vfork函数的调用序列和返回值与fork相同,但两者的语义不同。

    v f o r k用于创建一个新进程,而该新进程的目的是 e x e c一个新程序 (如上节(2) 中一样)。
    s h e l l基本部分就是这种类型程序的一个例子。
    v f o r k与f o r k一样都创建一个子进程,但是它并不将父进程的地址空间完全复制到子进程中,
    因为子进程会立即调用 exec(或exit),于是也就不会存访该地址空间。不过在子进程调用 e x e c或e x i t之前,它在父进程的空间中运行。
    这种工作方式在某些 U N I X的页式虚存实现中提高了效率(与上节中提及的,在 f o r k之后跟随
    exec,并采用在写时复制技术相类似)。

    vfork和fork之间的另一个区别是: vfork保证子进程先运行,在它调用 exec或exit之后父进
    程才可能被调度运行。(如果在调用这两个函数之前子进程依赖于父进程的进一步动作,则会导致死锁。)

    vfork 函数实例

    #include <sys/types.h>
    #include "ourhdr.h"

    int glob = 6;

    int
    main(void)
    {
      int var;
      pid_t pid;

      var = 88;
      printf("before vfork\n");
      if ((pid = vfork()) < 0)
        err_sys("vfork error");
      else if (pid == 0) {
        glob++;
        var++;
        _exit(0);
      }
      printf("pid = %d, glob = %d, var = %d\n", getpid(), glob, var);
      exit(0);
    }

    $ a.out
    before vfork
    pid = 607, glob = 7, var = 89
    子进程对变量 glob和var做增1操作,结果改变了父进程中的变量值。因为子进程在父进程的地
    址空间中运行,所以这并不令人惊讶。但是其作用的确与 fork不同。
    注意,在程序8-2中,调用了 _exit而不是exit。正如8.5节所述,_exit并不执行标准I/O缓存
    的刷新操作。如果用exit而不是_exit,则该程序的输出是:
    $ a.out
    before vfork
    从中可见,父进程 printf的输出消失了。其原因是子进程调用了 exit,它刷新开关闭了所有标准
    I / O流,这包括标准输出。虽然这是由子进程执行的,但却是在父进程的地址空间中进行的,
    所以所有受到影响的标准 I/O FILE对象都是在父进程中的。当父进程调用 printf时,标准输出已
    被关闭了,于是printf返回-1。

  8.5 exit函数

    (1) 正常终止:
    (a) 在main函数内执行return语句。如在7.3节中所述,这等效于调用 exit。
    (b) 调用exit函数。此函数由ANSI C定义,其操作包括调用各终止处理程序(终止处理程序
    在调用atexit函数时登录)
    ,
    然后关闭所有标准I/O流等。
    因为ANSI C并不处理文件描述符、
    多进程(父、子进程)以及作业控制,所以这一定义对
    UNIX系统而言是不完整的。
    (c) 调用_ e x i t系统调用函数。此函数由 e x i t调用,它处理 U N I X特定的细节。 _ e x i t是由
    POSIX.1说明的。
    (2) 异常终止:
    (a) 调用abort。它产生SIGABRT信号,所以是下一种异常终止的一种特例。
    (b) 当进程接收到某个信号时。
    (第1 0章将较详细地说明信号。
    )进程本身(例如调用
    a b o r t函数)
    、其他进程和内核都能产生传送到某一进程的信号。例如,进程越出其
    地址空间访问存储单元,或者除以 0,内核就会为该进程产生相应的信号。

    不管进程如何终止,最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打
    开描述符,释放它所使用的存储器等等。

    任意一种终止情形,我们都希望终止进程能够通知其父进程它是如何终止的。对
    于e x i t和_ e x i t,这是依靠传递给它们的退出状态( exit status)参数来实现的。在异常终止情
    况,内核(不是进程本身)产生一个指示其异常终止原因的终止状态( termination status)
    。
    在任意一种情况下,该终止进程的父进程都能用 wait或waitpid函数(在下一节说明 )取得其终止
    状态。

    在说明fork函数时,一定是一个父进程生成一个子进程。上面又说明了子进程将其终止状
    态返回给父进程。但是如果父进程在子进程之前终止,则将如何呢 ?其回答是对于其父进程已
    经终止的所有进程,它们的父进程都改变为 init进程。我们称这些进程由 init进程领养。其操作
    过程大致是:在一个进程终止时,内核逐个检查所有活动进程,以判断它是否是正要终止的进
    程的子进程,如果是,则该进程的父进程 ID就更改为1(init进程的ID)。这种处理方法保证了每
    个进程有一个父进程。

    当终止进程的父进程调用 w a i t或waitpid 时,可以得到有关信息。这种信息至少包括
    进程I D、该进程的终止状态、以反该进程使用的 C P U时间总量。

    内核可以释放终止进程所使用的所有存储器,关闭其所有打开文件。

    在 U N I X术语中,一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、
    释放它仍占用的资源)的进程被称为僵死进程( z o m b i e)

    一个由 init进程领养的进程终止时会发生什么 ?它会不会变成一
    个僵死进程?对此问题的回答是“否”
    ,因为 i n i t被编写成只要有一个子进程终止, i n i t就会调
    用一个wait函数取得其终止状态。这样也就防止了在系统中有很多僵死进程。当提及“一个 init
    的子进程”时,这指的是 i n i t直接产生的进程 (例如,将在9 . 2节说明的 g e t t y进程),或者是其父
    进程已终止,由 init 领养的进程。

  8.6 wait和waitpid函数

    当一个进程正常或异常终止时,内核就向其父进程发送 S I G C H L D信号。因为子进程终止
    是个异步事件 (这可以在父进程运行的任何时候发生 ),所以这种信号也是内核向父进程发的异
    步通知。父进程可以忽略该信号,或者提供一个该信号发生时即被调用执行的函数 (信号处理
    程序)。对于这种信号的系统默认动作是忽略它。第 1 0章将说明这些选择项。现在需要知道的
    是调用wait或waitpid的进程可能会:
    • 阻塞(如果其所有子进程都还在运行 )。
    • 带子进程的终止状态立即返回 (如果一个子进程已终止,正等待父进程存取其终止状态 )。
    • 出错立即返回(如果它没有任何子进程)。
    如果进程由于接收到 SIGCHLD信号而调用 wait,则可期望wait会立即返回。但是如果在一
    个任一时刻调用 wait,则进程可能会阻塞。

    p i d _ t w a i t ( i n t st*
    atloc) ;
    p i d _ t w a i t p i d ( p i d _p
    t
    id, i n t *
    statloc, i n t options) ;
    两个函数返回:若成功则为进程 I D,若出错则为- 1

    这两个函数的区别是:
    • 在一个子进程终止前, wait 使其调用者阻塞,而 waitpid 有一选择项,可使调用者不阻
    塞。
    • waitpid并不等待第一个终止的子进程—它有若干个选择项,可以控制它所等待的进程。
    如果一个子进程已经终止,是一个僵死进程,则 wait立即返回并取得该子进程的状态,否
    则wait使其调用者阻塞直到一个子进程终止。如调用者阻塞而且它有多个子进程,则在其一个
    子进程终止时, wait就立即返回。因为 wait返回终止子进程的进程 ID,所以它总能了解是哪一
    个子进程终止了。
    这两个函数的参数 s t a t l o c是一个整型指针。如果 s t a t l o c不是一个空指针,则终止进程的终
    止状态就存放在它所指向的单元内。如果不关心终止状态,则可将该参数指定为空指针。

    如果一个进程要 fork一个子进程,但不要求它等待
    子进程终止,也不希望子进程处于僵死状态直到父进程终止,实现这一要求的诀窍是调用 fork
    两次。

    在第二个子进程中调用 s l e e p以保证在打印父进程 I D时第一个子进程已终止。在 f o r k之后,
    父、子进程都可继续执行——我们无法预知哪一个会先执行。如果不使第二个子进程睡眠,则
    在fork之后,它可能比其父进程先执行,于是它打印的父进程 ID将是创建它的父进程,而不是
    init进程(进程ID 1)

  8.7 wait3和wait4函数

  8.8 竞态条件

    